{"version":3,"sources":["components/Form.js","Constants.js","components/StationsForLine.js","components/JourneyLeg.js","components/Path.js","path/orderedLines.js","path/stationBfs.js","App.js","reportWebVitals.js","index.js"],"names":["CustomDropDown","styled","Dropdown","Form","props","stations","setOrigin","setDestination","origin","destination","options","useMemo","Object","keys","map","key","text","value","handleChange","setValue","e","Header","as","fluid","onChange","clearable","search","placeholder","selection","defaultProps","undefined","LINE_COLOR_MAP","EW","CG","NS","NE","CC","CE","DT","TE","JW","JS","CR","BP","SE","SW","PE","PW","StationWrapper","ul","color","StationsForLine","stops","line","station","Clickable","div","Expand","Wrapper","JourneyLeg","useState","expanded","setExpanded","index","lineOrder","lastStop","pop","firstStop","onClick","length","Icon","name","Path","path","String","Message","lineMap","stationsTravelled","changes","numberOfStations","join","orderedLines","result","entries","forEach","lines","lineName","lineNumber","orderedLine","Array","isArray","number","isInterchange","createGraph","lineChangeWeight","graph","Graph","directed","multigraph","orderedStationsByLine","stationsForLine","minStationNumber","Math","min","num","Number","maxStationNumber","max","currentStationNumber","includes","nextStationNumber","currentStation","nextStation","currentStationName","nextStationName","setEdge","setLineChangeWeight","stationName","line1","line2","getLineWiseInterchangeName","push","edgeFunction","v","nodeEdges","constructPath","pathMap","source","previousStop","previousStopWithoutLine","split","edge","predecessor","lineStationList","unshift","reverse","i","previousLineStations","lastStopOfPreviousLine","getShortestPath","weightedGraph","STATION_NAMES","Error","sources","destinations","weightFunction","edgeValue","isNaN","minCost","Infinity","minPathMap","minPathOrigin","minPathDestination","start","alg","dijkstra","end","cost","distance","AppWrapper","Container","CustomRadio","Radio","FormWrapper","Grid","Column","App","setPath","setWeight","STATIONS","setGraph","useEffect","_","Divider","columns","width","Row","label","checked","Button","content","disabled","primary","calculated","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.db89b8f4.chunk.js","sourcesContent":["import { Dropdown, Header } from \"semantic-ui-react\";\nimport PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\nimport { useMemo } from \"react\";\n\nconst CustomDropDown = styled(Dropdown)`\n  margin-bottom: 25px;\n`;\n\nconst Form = (props) => {\n  const { stations, setOrigin, setDestination, origin, destination } = props;\n  const options = useMemo(\n    () =>\n      Object.keys(stations).map((key) => ({\n        key,\n        text: key,\n        value: key,\n      })),\n    []\n  );\n\n  const handleChange = (setValue) => (e, { value }) => {\n    setValue(value);\n  };\n\n  return (\n    <>\n      <Header as=\"h5\">From</Header>\n      <CustomDropDown\n        fluid\n        value={origin}\n        onChange={handleChange(setOrigin)}\n        clearable\n        search\n        placeholder=\"Origin\"\n        options={options}\n        selection\n      />\n      <Header as=\"h5\">To</Header>\n      <CustomDropDown\n        fluid\n        value={destination}\n        onChange={handleChange(setDestination)}\n        clearable\n        search\n        placeholder=\"Destination\"\n        options={options}\n        selection\n      />\n    </>\n  );\n};\n\nForm.propTypes = {\n  stations: PropTypes.object,\n  setOrigin: PropTypes.func.isRequired,\n  setDestination: PropTypes.func.isRequired,\n  origin: PropTypes.string,\n  destination: PropTypes.string,\n};\n\nForm.defaultProps = {\n  stations: {},\n  origin: undefined,\n  destination: undefined,\n};\n\nexport default Form;\n","export const LINE_COLOR_MAP = {\n  EW: \"#009743\",\n  CG: \"#009743\",\n  NS: \"#D52A0A\",\n  NE: \"#9A00AC\",\n  CC: \"#FA9F05\",\n  CE: \"#FA9F05\",\n  DT: \"#005EC5\",\n  TE: \"#793E02\",\n  JW: \"#009AAC\",\n  JS: \"#009AAC\",\n  CR: \"#79BF1A\",\n  BP: \"#9A9A9A\",\n  SE: \"#9A9A9A\",\n  SW: \"#9A9A9A\",\n  PE: \"#9A9A9A\",\n  PW: \"#9A9A9A\",\n};\n","import PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\nimport { LINE_COLOR_MAP } from \"../Constants\";\n\nconst StationWrapper = styled.ul`\n  border-left: 5px solid ${({ color }) => `${color || \"white\"}`};\n  padding: 0 12px;\n  margin: 0 10px;\n`;\n\nconst StationsForLine = (props) => {\n  const { stops, line } = props;\n  const color = LINE_COLOR_MAP[line];\n  return (\n    <StationWrapper color={color}>\n      {stops.map((station) => (\n        <li key={station}>{station}</li>\n      ))}\n    </StationWrapper>\n  );\n};\n\nStationsForLine.propTypes = {\n  stops: PropTypes.arrayOf(PropTypes.string),\n  line: PropTypes.string,\n};\n\nStationsForLine.defaultProps = {\n  stops: [],\n  line: \"\",\n};\n\nexport default StationsForLine;\n","import { useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\nimport { Header, Icon } from \"semantic-ui-react\";\nimport StationsForLine from \"./StationsForLine\";\n\nconst Clickable = styled.div`\n  cursor: pointer;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n`;\n\nconst Expand = styled.div`\n  text-decoration: underline;\n`;\n\nconst Wrapper = styled.div`\n  margin: 10px 0;\n  border: 1px solid #dfdfdf;\n  padding: 5px;\n  border-radius: 3px;\n`;\n\nconst JourneyLeg = (props) => {\n  const [expanded, setExpanded] = useState(true);\n  const { line, stops, index, lineOrder } = props;\n  const lastStop = [...stops].pop();\n  const firstStop = stops[0];\n  const handleClick = () => setExpanded(!expanded);\n\n  return (\n    <Wrapper>\n      <Clickable onClick={handleClick}>\n        <Header as=\"h5\">\n          Travel on the {line} line from {firstStop} to {lastStop}\n        </Header>\n        <Expand>{expanded ? \"Collapse\" : \"Expand\"}</Expand>\n      </Clickable>\n      {expanded && <StationsForLine stops={stops} line={line} />}\n      {index < lineOrder.length - 1 && (\n        <div>\n          <Icon name=\"arrow right\" />\n          <Icon name=\"train\" />\n          Change to {lineOrder[index + 1]} line at {lastStop}\n        </div>\n      )}\n    </Wrapper>\n  );\n};\n\nJourneyLeg.propTypes = {\n  line: PropTypes.string.isRequired,\n  stops: PropTypes.arrayOf(PropTypes.string).isRequired,\n  index: PropTypes.number.isRequired,\n  lineOrder: PropTypes.arrayOf(PropTypes.string).isRequired,\n};\n\nexport default JourneyLeg;\n","import PropTypes from \"prop-types\";\nimport { Header, Message } from \"semantic-ui-react\";\nimport JourneyLeg from \"./JourneyLeg\";\n\nconst Path = (props) => {\n  const { path } = props;\n  if (typeof path === \"string\" || path instanceof String) {\n    return <Message>{path}</Message>;\n  }\n\n  if (path.stops === undefined) {\n    return null;\n  }\n\n  const {\n    path: { stops, lineOrder, lineMap, stationsTravelled },\n  } = props;\n  const changes = stops.length - 2;\n  const numberOfStations = stationsTravelled.length;\n\n  return (\n    <>\n      <div>\n        <Header as=\"h4\">\n          This path is {numberOfStations} mrt stations long with {changes}{\" \"}\n          {changes === 1 ? \"change\" : \"changes\"}\n        </Header>\n        <Header as=\"h5\">{stops.join(\" -> \")}</Header>\n        {lineOrder.map((line, index) => {\n          return (\n            <JourneyLeg\n              key={line}\n              line={line}\n              stops={lineMap[line]}\n              index={index}\n              lineOrder={lineOrder}\n            />\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nPath.propTypes = {\n  path: PropTypes.oneOfType([\n    PropTypes.shape({\n      stationsTravelled: PropTypes.arrayOf(PropTypes.string),\n      stops: PropTypes.arrayOf(PropTypes.string),\n      lineMap: PropTypes.object,\n      lineOrder: PropTypes.arrayOf(PropTypes.string),\n    }),\n    PropTypes.string,\n  ]),\n};\n\nPath.defaultProps = {\n  path: { stationsTravelled: [] },\n  stops: [],\n  lineMap: {},\n  lineOrder: [],\n};\n\nexport default Path;\n","export function orderedLines(stations) {\n  const result = {};\n  Object.entries(stations).forEach(([station, lines]) => {\n    Object.entries(lines).forEach(([lineName, lineNumber]) => {\n      const orderedLine = result[lineName] || {};\n      if (Array.isArray(lineNumber)) {\n        lineNumber.forEach((number) => {\n          orderedLine[number] = station;\n        });\n      } else {\n        orderedLine[lineNumber] = station;\n      }\n      result[lineName] = orderedLine;\n    });\n  });\n  return result;\n}\n","import { Graph, alg } from \"@dagrejs/graphlib\";\nimport { orderedLines } from \"./orderedLines\";\n\nfunction isInterchange(station, stations) {\n  return Object.keys(stations[station]).length > 1;\n}\n\nexport function createGraph(stations, lineChangeWeight = 1) {\n  const graph = new Graph({ directed: false, multigraph: true });\n  const orderedStationsByLine = orderedLines(stations);\n  Object.entries(orderedStationsByLine).forEach(\n    ([lineName, stationsForLine]) => {\n      const minStationNumber = Math.min(\n        ...Object.keys(stationsForLine).map((num) => Number(num))\n      );\n      const maxStationNumber = Math.max(\n        ...Object.keys(stationsForLine).map((num) => Number(num))\n      );\n      let currentStationNumber = minStationNumber;\n      while (currentStationNumber < maxStationNumber) {\n        if (\n          Object.keys(stationsForLine).includes(String(currentStationNumber))\n        ) {\n          let nextStationNumber = currentStationNumber + 1;\n          while (\n            !Object.keys(stationsForLine).includes(String(nextStationNumber)) &&\n            nextStationNumber <= maxStationNumber\n          ) {\n            nextStationNumber += 1;\n          }\n          const currentStation = stationsForLine[String(currentStationNumber)];\n          const nextStation = stationsForLine[String(nextStationNumber)];\n          const currentStationName = isInterchange(currentStation, stations)\n            ? currentStation + \"-\" + lineName\n            : currentStation;\n          const nextStationName = isInterchange(nextStation, stations)\n            ? nextStation + \"-\" + lineName\n            : nextStation;\n          graph.setEdge(currentStationName, nextStationName, lineName);\n          currentStationNumber = nextStationNumber;\n        } else {\n          currentStationNumber += 1;\n        }\n      }\n    }\n  );\n\n  setLineChangeWeight(graph, stations, lineChangeWeight);\n  return graph;\n}\n\nexport function setLineChangeWeight(graph, stations, lineChangeWeight) {\n  Object.entries(stations).forEach(([stationName, lines]) => {\n    if (Object.keys(lines).length > 1) {\n      Object.keys(lines).forEach((line1) =>\n        Object.keys(lines).forEach((line2) => {\n          if (line1 !== line2) {\n            graph.setEdge(\n              `${stationName}-${line1}`,\n              `${stationName}-${line2}`,\n              lineChangeWeight,\n              \"interchange\"\n            );\n          }\n        })\n      );\n    }\n  });\n}\n\nfunction getLineWiseInterchangeName(station, stations) {\n  const result = [];\n  if (isInterchange(station, stations)) {\n    Object.keys(stations[station]).forEach((line) =>\n      result.push(`${station}-${line}`)\n    );\n  } else {\n    result.push(station);\n  }\n  return result;\n}\n\nconst edgeFunction = (graph) => (v) => graph.nodeEdges(v);\n\nfunction constructPath(pathMap, source, destination, graph) {\n  const stationsTravelled = [];\n  const lineOrder = [];\n  const lineMap = {};\n  let previousStop = destination;\n  while (previousStop !== source) {\n    const previousStopWithoutLine = previousStop.split(\"-\")[0];\n    if (!stationsTravelled.includes(previousStopWithoutLine)) {\n      stationsTravelled.push(previousStopWithoutLine);\n    }\n    const line = graph.edge(previousStop, pathMap[previousStop].predecessor);\n    if (line !== undefined) {\n      if (!lineOrder.includes(line)) {\n        lineOrder.push(line);\n      }\n      const lineStationList = lineMap[line] || [];\n      lineStationList.unshift(previousStopWithoutLine);\n      previousStop = pathMap[previousStop].predecessor;\n      if (previousStop === source) {\n        lineStationList.unshift(previousStop.split(\"-\")[0]);\n      }\n      lineMap[line] = lineStationList;\n    } else {\n      previousStop = pathMap[previousStop].predecessor;\n    }\n  }\n  stationsTravelled.push(source.split(\"-\")[0]);\n  stationsTravelled.reverse();\n  lineOrder.reverse();\n  const stops = [source.split(\"-\")[0]];\n  lineOrder.forEach((line) => stops.push([...lineMap[line]].pop()));\n  for (let i = 1; i < stops.length - 1; i++) {\n    const previousLineStations = lineMap[lineOrder[i - 1]];\n    const lastStopOfPreviousLine =\n      previousLineStations[previousLineStations.length - 1];\n    lineMap[lineOrder[i]].unshift(lastStopOfPreviousLine);\n  }\n  return { lineMap, lineOrder, stationsTravelled, stops };\n}\n\nexport function getShortestPath(\n  source,\n  destination,\n  stations,\n  lineChangeWeight = 1,\n  weightedGraph = null\n) {\n  const STATION_NAMES = Object.keys(stations);\n  if (!STATION_NAMES.includes(source) || !STATION_NAMES.includes(destination)) {\n    throw new Error(\"Invalid station, cannot calculate path\");\n  }\n  const graph =\n    weightedGraph === null\n      ? createGraph(stations, lineChangeWeight)\n      : weightedGraph;\n  const sources = getLineWiseInterchangeName(source, stations);\n  const destinations = getLineWiseInterchangeName(destination, stations);\n\n  const weightFunction = (e) => {\n    const edgeValue = graph.edge(e);\n    if (isNaN(edgeValue)) return 1;\n    return edgeValue;\n  };\n\n  let minCost = Infinity;\n  let minPathMap = undefined;\n  let minPathOrigin = undefined;\n  let minPathDestination = undefined;\n\n  sources.forEach((start) => {\n    const pathMap = alg.dijkstra(\n      graph,\n      start,\n      weightFunction,\n      edgeFunction(graph)\n    );\n    destinations.forEach((end) => {\n      const cost = pathMap[end].distance;\n      if (cost < minCost) {\n        minCost = cost;\n        minPathMap = pathMap;\n        minPathOrigin = start;\n        minPathDestination = end;\n      }\n    });\n  });\n\n  if (minCost === Infinity) {\n    return \"Sorry, no path found!\";\n  }\n\n  return constructPath(minPathMap, minPathOrigin, minPathDestination, graph);\n}\n","import { useEffect, useState } from \"react\";\nimport {\n  Button,\n  Container,\n  Divider,\n  Grid,\n  Header,\n  Message,\n  Radio,\n} from \"semantic-ui-react\";\nimport styled from \"styled-components\";\nimport \"./App.css\";\nimport Form from \"./components/Form\";\nimport STATIONS from \"./stations\";\nimport Path from \"./components/Path\";\nimport {\n  createGraph,\n  getShortestPath,\n  setLineChangeWeight,\n} from \"./path/stationBfs\";\n\nconst AppWrapper = styled(Container)`\n  padding-top: 20px;\n`;\n\nconst CustomRadio = styled(Radio)`\n  margin-bottom: 15px;\n`;\nconst FormWrapper = styled(Grid.Column)`\n  background: #dfdfdf;\n  border-radius: 3px;\n`;\n\nfunction App() {\n  const [origin, setOrigin] = useState();\n  const [destination, setDestination] = useState();\n  const [path, setPath] = useState({});\n  const [lineChangeWeight, setWeight] = useState(1);\n  const [graph, setGraph] = useState(createGraph(STATIONS, lineChangeWeight));\n\n  useEffect(() => {\n    setLineChangeWeight(graph, STATIONS, lineChangeWeight);\n    setGraph(graph);\n    if (origin && destination) {\n      setPath(\n        getShortestPath(origin, destination, STATIONS, lineChangeWeight, graph)\n      );\n    }\n  }, [lineChangeWeight]);\n\n  useEffect(() => {\n    setPath({});\n  }, [origin, destination]);\n\n  const handleClick = () => {\n    const calculated = getShortestPath(origin, destination, STATIONS, 1, graph);\n    setPath(calculated);\n  };\n  const handleChange = (_, { value }) => setWeight(value);\n\n  return (\n    <AppWrapper>\n      <Header as=\"h2\">MRT Path Finder</Header>\n      <Divider />\n      <Grid columns={2}>\n        <FormWrapper width={5}>\n          <Grid.Row>\n            <Header as=\"h5\">Find a path with - </Header>\n            <CustomRadio\n              label=\"least stations\"\n              name=\"lineWeightGroup\"\n              value={1}\n              checked={lineChangeWeight === 1}\n              onChange={handleChange}\n            />\n            <br />\n            <CustomRadio\n              label=\"least changes in MRT line\"\n              name=\"lineWeightGroup\"\n              value={15}\n              checked={lineChangeWeight === 15}\n              onChange={handleChange}\n            />\n          </Grid.Row>\n          <Grid.Row>\n            <Form\n              origin={origin}\n              destination={destination}\n              setOrigin={setOrigin}\n              setDestination={setDestination}\n              stations={STATIONS}\n            />\n          </Grid.Row>\n          <Grid.Row>\n            <Button\n              content=\"Find me a path!\"\n              fluid\n              disabled={!origin || !destination}\n              primary\n              onClick={handleClick}\n            />\n          </Grid.Row>\n        </FormWrapper>\n        <Grid.Column width={11}>\n          {origin && destination && origin === destination ? (\n            <Message> You are already where you want to be</Message>\n          ) : (\n            <Path path={path} />\n          )}\n        </Grid.Column>\n      </Grid>\n    </AppWrapper>\n  );\n}\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}